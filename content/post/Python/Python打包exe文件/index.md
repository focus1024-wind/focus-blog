---
title: Python打包exe文件
description: Python打包exe文件
date: 2022-10-24
slug: python/build_exe
image: 
categories:
    - Python
tags:
    - Python
---

# 1 下载安装pyinstaller
```shell
pip install pyinstaller
```
# 2 使用pyinstaller打包生成exe文件
## 2.1 预打包：打包带控制台的exe文件，便于纠错
1. 创建带控制台的exe文件
```shell
pyinstaller [main.py]
```
1. 使用该命令，就会在当前路径下生成一个名dist的目录
2. 进入该目录，有一个和主程序同名的目录
3. 进入目录，找到同名的[main].exe文件，该文件即为打包生成的exe文件，同目录下其他文件则为相关的链接文件
4. pyinstaller打包时，只会动态链接相关的py文件中的库或py文件，不会导入静态资源文件，当项目在运行时需要依赖一些静态资源时，需要手动将这些文件复制在dist目录下的同名目录下
5. 打包时，有一些依赖无法直接导入，所以需要使用`--hidden-import`参数隐式导入无法导入的库
6. 运行exe文件，查看控制台输出：
7. 若控制台输出：NO Mould Named XXX，则说明XXX包不存在或不兼容，重新下载该包
8. 若控制台输出ImportError，则说明该包为动态导入的包，需要使用 `--hidden-import`参数隐式导入
```shell
pyinstaller [main.py] --hidden-import "隐式导入的包名"
```
## 2.2 正式打包
使用带控制台方式打包exe文件，纠正完打包中可能存在的异常情况后，即可正式将项目打包为正式exe文件，使用 `--noconsole` 参数生成不带控制台的exe文件
```shell
pyinstaller [main.py] --noconsole --hidden-import "隐式导入的包名"
```
# 3 pyinstaller相关参数说明
| 参数 | 说明 |
| --- | --- |
| -F，-onefile | 打包时将项目打包为单个可执行文件，打包后的文件相对较小 |
| -D，--onedir（默认） | 产生一个目录作为可执行文件，打包后的文件相对较大 |
| w，--windowed，--noconsolc | 指定程序运行时不显示命令行窗口（仅对 Windows 有效） |
| -c，--nowindowed，--console（默认） | 指定使用命令行窗口运行程序（仅对 Windows 有效） |
| --icon | 设置打包后的exe文件的icon图标，只支持ico文件，若为png，jpg等文件，可使用相关在线工具将格式转换为ico文件再打包 |
| --hidden-import | 隐式导入无法导入的包 |

**注：在打包时，不建议使用**`**-F**`**参数，使用**`**-F**`**打包后的单个exe文件，虽然文件较小，但是启动较慢，并且**`**-F**`**文件无法很好的处理静态资源**

# 4 优化打包后的目录结构，将库文件放入lib文件夹中
将exe文件打包为目录结构的话，exe同级文件夹下会有很多的库文件夹和dll文件，此时会造成两个问题：
1. 无法很快的定位到exe文件
2. 目录结构混乱

为解决此问题，优化目录结构，可以将相关的依赖放在指定文件夹中，可执行文件放在外部，如，在外部创建可执行文件的快捷方式，将可执行程序的目录命名为lib即可完成此操作。此方法在免安装环境下，即将程序提供给他人时使用压缩包的方式可有效实行，方便快捷。

但是在将程序打包为可安装软件时，此方法无法正常执行，快捷方式在作为主程序时会自动执行为exe可执行文件，打包安装软件时，会自动将快捷方式重定向到可执行exe文件，导致安装软件后，安装目录下有两个可执行文件，一个为lib目录下的可执行文件的exe文件，一个为快捷方式，运行可执行的exe文件时，因为可执行文件实际的运行路径为lib目录下，而生成的可执行文件为在安装目录下，所以运行改可执行exe文件会报错，运行快捷方式可正常运行。

打包安装文件时，使用快捷方式作为主程序文件：
1. 安装后会生成lib路径下可执行文件的副本，但是因为路径问题，此副本无法运行，若在安装时生成桌面快捷方式，则桌面快捷方式指向此副本，同样无法执行
2. 安装目录下会包含快捷方式，使用快捷方式可正常运行

若将这样的安装包提供给他人使用时，则这样的安装包会造成一些额外影响，所以在打包安装包时，不易使用快捷方式作为主程序。

使用快捷方式执行主程序，本质上是将程序重定向到lib路径下的可执行程序，既然在打包安装包时，不能使用快捷方式，那么转变思维，使用其他方法，打开lib路径下的可执行程序即可。如：写一个脚本，打开lib下的可执行程序，该脚本虽然在启动可执行程序的原理上与快捷方式不同，但是在效果上，都完成的是一件事情：打开lib路径下的可执行程序。

在这里，我使用的golang写了一个打开指定文件的程序，然后生成可执行文件，替换原快捷方式。
**Windows下使用GoLang调用exe文件：**
```go
package main

import (
	"os/exec"
)

func main()  {
	file_parent_path := "./lib/"
	file_name := "application.exe"

	file_path := file_parent_path + file_name
	cmd := exec.Command("cmd", "/c", "start ", file_path)
	cmd.Run()
}
```
**该方法的核心思想是生成一个可打开指定程序的程序，不必拘泥于脚本的形式，根据项目需求和条件，快速写一个脚本或程序即可达到指定需求，这里的golang调用exe文件只是一个例子。**
